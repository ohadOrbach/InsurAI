---
description:
globs:
alwaysApply: false
---
# RIPER Workflow with Memory Bank Integration

## MEMORY BANK TRACKING

You MUST maintain workflow memory across all RIPER stages. The memory bank tracks:
- Stage completion status
- Knowledge accumulated in each stage
- Decisions made and rationale
- Cross-stage dependencies
- Learning outcomes
- Task progress and execution history

### Memory Bank Structure
```
memory-bank/
├── workflow/
│   ├── riper-state.json          # Current workflow state
│   ├── stage-completions.json    # Stage completion history
│   ├── knowledge-base.json       # Accumulated knowledge
│   └── decisions.json             # Decision log
├── tasks/
│   ├── tasks.json                # Task definitions from PRD
│   ├── current-task.json         # Currently selected task
│   ├── progress-log.md           # Task completion history
│   └── iteration-state.json      # Automated iteration state
├── research/
│   ├── findings.md               # Research discoveries
│   └── sources.md                # Research sources
├── innovate/
│   ├── ideas.md                  # Innovation concepts
│   └── evaluations.md            # Idea evaluations
├── plan/
│   ├── specifications.md         # Detailed plans
│   └── dependencies.md           # Planning dependencies
├── execute/
│   ├── implementation-log.md     # Execution progress
│   └── code-changes.md           # Code modification log
└── review/
    ├── assessment.md             # Review outcomes
    └── improvements.md           # Identified improvements
```

## TASK-ENHANCED STAGE BEHAVIOR

### RESEARCH Mode + Tasks
When in RESEARCH mode with active tasks:
1. **Load Task Context**: Read current task research requirements
2. **Execute Research Subtasks**: Focus on task-specific information gathering
3. **Document Findings**: Update both general research files and task-specific research
4. **Update Task Progress**: Mark research subtasks as completed

### INNOVATE Mode + Tasks  
When in INNOVATE mode with active tasks:
1. **Load Research Findings**: Import task-specific research results
2. **Generate Solutions**: Create approaches specifically for current task
3. **Evaluate Options**: Assess solutions against task requirements
4. **Select Approach**: Choose optimal solution for planning phase

### PLAN Mode + Tasks
When in PLAN mode with active tasks:
1. **PRD Parsing**: Use `/parse-prd` to break down requirements into tasks
2. **Task Selection**: Choose next task to plan with `/select-task` or `/next-task`
3. **Detailed Planning**: Create implementation plans for selected task
4. **File Identification**: Specify exact files that need modification

### EXECUTE Mode + Tasks
When in EXECUTE mode with active tasks:
1. **Load Task Plan**: Import detailed implementation plan
2. **File Modifications**: Execute planned changes to specified files
3. **Progress Tracking**: Update task status as implementation progresses
4. **Code Logging**: Document all changes in implementation log

### REVIEW Mode + Tasks
When in REVIEW mode with active tasks:
1. **Implementation Validation**: Verify task implementation meets requirements
2. **Quality Checks**: Run tests and validation procedures
3. **Task Completion**: Mark tasks as fully completed
4. **Learning Capture**: Document insights for future tasks

## STAGE TRANSITION PROTOCOL

### Before Stage Entry
1. **Update riper-state.json** with new stage
2. **Save Current Task Context** to memory bank
3. **Create stage directory** if not exists
4. **Initialize stage files** with templates
5. **Check prerequisites** from previous stages
6. **Load Task Context** for new stage

### During Stage Execution
1. **Log all activities** in stage-specific files
2. **Update knowledge-base.json** with discoveries
3. **Record decisions** in decisions.json
4. **Maintain cross-references** between stages
5. **Update task progress** continuously
6. **Track task-specific subtask completion**

### After Stage Completion
1. **Mark stage complete** in stage-completions.json
2. **Update task status** if applicable
3. **Summary artifacts** created
4. **Knowledge transfer** to next stage prepared
5. **Progress metrics** updated
6. **Task iteration check** - auto-select next task if enabled

## ENHANCED WORKFLOW COMMANDS

### Standard Mode Commands (Task-Enhanced)
- `/research` → RESEARCH + load research tasks + initialize research memory
- `/innovate` → INNOVATE + load innovation tasks + initialize innovation memory
- `/plan` → PLAN + load planning tasks + initialize planning memory + enable PRD parsing
- `/execute` → EXECUTE + load execution tasks + initialize execution memory
- `/review` → REVIEW + load review tasks + initialize review memory

### Task Management Commands
- `/parse-prd` → Parse PRD into tasks (PLAN mode required)
- `/list-tasks` → Show all tasks with current status
- `/select-task <task_id>` → Select specific task for execution
- `/next-task` → Auto-select next task based on priority and dependencies
- `/task-status` → Show current task and overall progress
- `/complete-task` → Mark current task as completed and update progress

### Task Iteration Commands
- `/iterate-tasks` → Execute all pending tasks automatically across RIPER modes
- `/pause-iteration` → Pause automatic task iteration
- `/resume-iteration` → Resume automatic task iteration from last state

### Memory Commands (Enhanced)
- `/memory-status` → Show current workflow state, memory, and task progress
- `/memory-export` → Export workflow memory and task data to files
- `/memory-reset` → Reset workflow memory (requires confirmation)
- `/stage-summary` → Generate summary of current stage including task progress

## AUTOMATED TASK ITERATION

When `/iterate-tasks` is executed:
1. **Load Task Queue**: Get all pending tasks ordered by priority
2. **Dependency Check**: Verify dependencies are met for next task
3. **Mode Alignment**: Switch to appropriate RIPER mode for task
4. **Execute Task**: Run task-specific subtasks in current mode
5. **Progress Update**: Mark subtasks and tasks as completed
6. **Continue**: Move to next task until queue is empty or user intervention

### Iteration Safety Protocols
- **User Confirmation**: Required for destructive operations
- **Progress Checkpoints**: Save state at each major step
- **Error Recovery**: Pause iteration on errors, allow manual resolution
- **Override Capability**: User can `/pause-iteration` at any time

## MODE-SPECIFIC MEMORY BEHAVIOR (Enhanced)

### RESEARCH Mode
- **Input Memory**: Previous research, project context, current task research requirements
- **Track**: Sources, findings, insights, questions, task-specific research progress
- **Output Memory**: Research knowledge base for innovation + task research completion

### INNOVATE Mode  
- **Input Memory**: Research findings, previous innovations, current task requirements
- **Track**: Ideas, evaluations, selections, reasoning, task-specific solutions
- **Output Memory**: Selected innovations for planning + task solution approach

### PLAN Mode
- **Input Memory**: Selected innovations, previous plans, current task solution
- **Track**: Specifications, dependencies, timelines, risks, task implementation plans
- **Output Memory**: Detailed implementation plans + task execution roadmap

### EXECUTE Mode
- **Input Memory**: Implementation plans, previous executions, current task plan
- **Track**: Code changes, progress, issues, solutions, task implementation status
- **Output Memory**: Implementation results for review + task completion status

### REVIEW Mode
- **Input Memory**: Implementation results, previous reviews, completed task results
- **Track**: Assessments, learnings, improvements, task validation results
- **Output Memory**: Review outcomes for next cycle + task completion confirmation

## WORKFLOW CONTINUITY (Enhanced)

### Session Recovery
- Load riper-state.json to determine current stage
- Load current-task.json to determine active task
- Load stage-specific memory for context
- Resume from last known state with task context

### Task-Aware Dependencies
- INNOVATE requires RESEARCH memory + task research completion
- PLAN requires INNOVATE memory + task solution approach
- EXECUTE requires PLAN memory + task implementation plan
- REVIEW requires EXECUTE memory + task implementation results

### Knowledge Accumulation (Task-Enhanced)
- Each stage builds on previous knowledge + task-specific insights
- Knowledge base grows throughout workflow + captures task learnings
- Learning transfers to subsequent cycles + improves task execution
- Task patterns and solutions are preserved for reuse
